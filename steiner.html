<html>
<style>

  body {
    font: 14px helvetica neue, helvetica, arial, sans-serif;
  }

  .absolute-full {
    height: 100%;
    width: 100%;
    position: absolute;
  }

  .control-button {
    margin: 10px;
    width: 50px;
    height: 30px;
    font-size: 20px;
  }

  .benchmark-button {
    margin: 10px;
    height: 30px;
    font-size: 20px;
  }

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.2.5/cytoscape.js"></script>

<div class="absolute-full">
  <div>
    <input type="button" value="+" class="control-button" onclick="addVertex()">

    <input type="button" value="-" class="control-button" onclick="removeVertex()">

    <input type="button" value="Benchmark" class="benchmark-button" onclick="benchmark()">
  </div>


  <div id="cy" class="absolute-full">

  </div>

</div>

<script>
  var vertexCount = 4;

  function addVertex() {
    clearAll();
    vertexCount++;
    main(vertexCount)
  }

  function removeVertex() {
    clearAll();
    vertexCount--;
    if (vertexCount < 1) {
      vertexCount = 1
    }
    main(vertexCount)
  }

  const cy = cytoscape({
    container: document.getElementById('cy'),

    layout: {
      name: 'random',
      padding: 10
    },

    style: cytoscape.stylesheet()
      .selector('node')
      .css({
        //'shape': 'data(faveShape)',
        //'width': 'mapData(40, 40, 80, 20, 60)',
        'content': 'data(name)',
        'text-valign': 'center',
        'text-outline-width': 2,
        'text-outline-color': 'data(faveColor)',
        'background-color': 'data(faveColor)',
        'color': '#fff'
      })

      .selector(':selected')
      .css({
        'border-width': 3,
        'border-color': '#333'
      })

      .selector('edge')
      .css({
        // 'curve-style': 'bezier',
        'opacity': 0.666,
        'width': 'mapData(strength, 70, 100, 2, 6)',
        'target-arrow-shape': 'triangle',
        'source-arrow-shape': 'circle',
        'line-color': 'data(faveColor)',
        'source-arrow-color': 'data(faveColor)',
        'target-arrow-color': 'data(faveColor)'
      })
      .selector('edge.questionable')
      .css({
        'line-style': 'dotted',
        'target-arrow-shape': 'diamond'
      })
      .selector('.faded')
      .css({
        'opacity': 0.25,
        'text-opacity': 0
      }),

    elements: {
      nodes: [],
      edges: []
    },

    ready: function () {
      window.cy = this;
    }
  });


  const mkVert = i => ({
    data: {
      id: i,
      name: i,
      faveColor: '#00FF00',
      isMain: true
    }
  })

  const mkVertExt = i => ({
    data: {
      id: i.id,
      name: '', //i.id,
      faveColor: '#444444',
      isMain: false
    },
    renderedPosition: {
      x: i.pos.x,
      y: i.pos.y
    }
  })

  const mkEdge = (a, b) => ({
    data: {
      source: a,
      target: b,
      faveColor: '#6FB1FC',
      strength: 90
    }
  })


  const drawGraph = (vs, es) => {
    vs.forEach(v => {
      cy.add(mkVert(v))
    })
    es.forEach(e => {
      cy.add(mkEdge(e[0], e[1]))
    })

    const layout = cy.layout({
      name: 'random'
    });

    layout.run();
  }

  const drawExt = (vs, es) => {
    vs.forEach(v => {
      cy.add(mkVertExt(v))
    })
    es.forEach(e => {
      cy.add(mkEdge(e.from.id, e.to.id))
    })
  }


  const clearComputedElements = () => {
    cy.remove(cy.elements('node[!isMain]'));
    cy.remove(cy.elements('edge'));
  }

  function clearAll() {
    cy.remove(cy.elements('node'));
    cy.remove(cy.elements('edge'));
  }

  function benchmark() {
    const testData = [{"id": "A", "pos": {"x": 69.2520325203252, "y": 236.64634146341456}}, {
      "id": "B",
      "pos": {"x": 48.47154471544715, "y": 651.1016260162601}
    }, {"id": "C", "pos": {"x": 501.0243902439024, "y": 501.020325203252}}, {
      "id": "D",
      "pos": {"x": 756.1626016260163, "y": 363.6382113821138}
    }, {"id": "E", "pos": {"x": 863.5284552845529, "y": 793.1016260162602}}, {
      "id": "F",
      "pos": {"x": 243.5772357723577, "y": 133.89837398373976}
    }];

    const st = new Date();
    const net = findOptimalSteinerNet(testData);
    const fn = new Date();
    const time = fn - st;
    alert(`time: ${time}\ncount: ${net.c}\nweight: ${Math.floor(net.w)}`)
  }

  function findOptimalSteinerNet(positions) {
    const slns = steiner(positions);
    return slns.reduce((acc, s) => {
      const w = evalWeigth(s);

      if (!acc || acc.w > w) {
        return {
          s: s,
          w: w,
          c: slns.length
        }
      } else {
        return acc
      }
    }, null)
  }

  function drawSteinerNet() {
    clearComputedElements();
    const positions = cy.elements('node[isMain]').map(v => ({
      id: v.id(),
      pos: v.renderedPosition()
    }))

    const opt = findOptimalSteinerNet(positions);

    drawExt(opt.s.vs, opt.s.es);
  }

  function main(count) {
    const initVertexes = []
    for (let i = 0; i < count; i++) {
      initVertexes.push(String.fromCharCode(65 + i))
    }

    drawGraph(initVertexes, [])

    cy.nodes().on('drag', () => drawSteinerNet());
    drawSteinerNet();
  }

  const select1 = ls => {
    const res = []
    for (let i = 0; i < ls.length; i++) {
      const cp = [...ls];
      cp.splice(i, 1)
      res.push({
        selected: ls[i],
        other: cp
      })
    }
    return res;
  }

  const select2 = ls => {
    const res = []
    for (let i = 0; i < ls.length; i++) {
      for (let j = i; j < ls.length - 1; j++) {
        const cp = [...ls];
        cp.splice(i, 1)
        cp.splice(j, 1)
        res.push({
          s1: ls[i],
          s2: ls[j + 1],
          other: cp
        })
      }
    }
    return res;
  }

  const getVertEdges = (v, net) => {
    return net.es.filter(e => e.from.id === v.id || e.to.id === v.id)
  }

  function cosEdgesAngle(a, b) {
    const ax = a.to.pos.x - a.from.pos.x;
    const ay = a.to.pos.y - a.from.pos.y;

    const bx = b.to.pos.x - b.from.pos.x;
    const by = b.to.pos.y - b.from.pos.y;

    return (ax * bx + ay * by) / Math.sqrt((ax * ax + ay * ay) * (bx * bx + by * by))
  }

  function normEdgeDir(e, vFrom) {
    if (e.from.id === vFrom.id) {
      return e;
    } else {
      return {
        from: e.to,
        to: e.from
      }
    }
  }

  function isAddable(cur, v, net) {
    const es = getVertEdges(v, net)
    if (es.length > 2) return false;

    const curEdge = {
      from: v,
      to: cur
    }

    return !es.some(e => cosEdgesAngle(curEdge, normEdgeDir(e, v)) > -1 / 2 + 0.001)
  }

  function evalWeigth(net) {
    return net.es.map(e => {
      const dx = e.from.pos.x - e.to.pos.x
      const dy = e.from.pos.y - e.to.pos.y
      return Math.sqrt(dx * dx + dy * dy)
    })
      .reduce((a, i) => a + i, 0)
  }

  function genTriangles(a, b) {
    const x = b.pos.x - a.pos.x
    const y = b.pos.y - a.pos.y

    return [{
      id: a.id + "-" + b.id + "-1",
      pos: {
        x: a.pos.x + Math.cos(Math.PI / 3) * x - Math.sin(Math.PI / 3) * y,
        y: a.pos.y + Math.sin(Math.PI / 3) * x + Math.cos(Math.PI / 3) * y
      }
    },
      {
        id: a.id + "-" + b.id + "-2",
        pos: {
          x: a.pos.x + Math.cos(-Math.PI / 3) * x - Math.sin(-Math.PI / 3) * y,
          y: a.pos.y + Math.sin(-Math.PI / 3) * x + Math.cos(-Math.PI / 3) * y
        }
      }
    ]
  }

  const genExtVertex = (s1, s2, m, k) => {

    const sx = (s1.pos.x + s2.pos.x + m.pos.x) / 3
    const sy = (s1.pos.y + s2.pos.y + m.pos.y) / 3

    const mcx = m.pos.x - sx
    const mcy = m.pos.y - sy

    const kcx = k.pos.x - sx
    const kcy = k.pos.y - sy

    const dx = kcx - mcx;
    const dy = kcy - mcy

    const t = -2 * (dx * mcx + dy * mcy) / (dx * dx + dy * dy)

    if (t > 1 || t < 0) return []

    const ecx = dx * t + mcx
    const ecy = dy * t + mcy

    const ex = ecx + sx
    const ey = ecy + sy

    return [{
      id: "(" + s1.id + ") - (" + s2.id + ") -> (" + k.id + ")",
      pos: {
        x: ex,
        y: ey
      }
    }]

  }

  function distSquare(a, b) {
    const dx = b.pos.x - a.pos.x;
    const dy = b.pos.y - a.pos.y;
    return dx * dx + dy * dy;
  }

  function steiner(positions) {
    if (positions.length <= 1) {
      return [{
        vs: [],
        es: []
      }]
    }
    if (positions.length === 2) {
      return [{
        vs: [],
        es: [{
          from: positions[0],
          to: positions[1]
        }]
      }]
    }

    const fstVars = select1(positions)
      .flatMap(s => {
        const cur = s.selected;
        const vs = s.other;

        const closest = vs.reduce((acc, i) => {
          if (!acc) {
            return i;
          }
          const distOld = distSquare(acc, cur);
          const distCur = distSquare(i, cur)
          return distCur < distOld ? i : acc
        }, null)

        return steiner(vs).flatMap(solution => {
          return [closest].filter(v => isAddable(cur, v, solution))
            .map(v => ({
              vs: solution.vs,
              es: [...solution.es, {
                from: cur,
                to: v
              }]
            }));
        })
      });


    const sndVars = select2(positions)
      .flatMap(s => {
        const s1 = s.s1;
        const s2 = s.s2;
        const vs = s.other


        return genTriangles(s1, s2).flatMap(m => {
          return steiner([...vs, m]).flatMap(solution => {
            const es = getVertEdges(m, solution)

            if (es.length !== 1) {
              return []
            }

            const k = es[0].from.id !== m.id ? es[0].from : es[0].to

            return genExtVertex(s1, s2, m, k).map(ext => {

              return {
                vs: [
                  ext,
                  ...solution.vs
                ],
                es: [{
                  from: s1,
                  to: ext
                },
                  {
                    from: s2,
                    to: ext
                  },
                  ...solution.es.map(e => {
                    if (e.from.id === m.id) {
                      return {
                        from: ext,
                        to: e.to
                      }
                    }
                    if (e.to.id === m.id) {
                      return {
                        from: e.from,
                        to: ext
                      }
                    }
                    return e
                  })
                ]
              }
            })
          })
        })

      })

    return [...fstVars, ...sndVars];
  }

  main(vertexCount)


</script>

</html>
